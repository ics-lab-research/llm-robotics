[
    {
        "instruction": "Could you refactor this URScript code to use a loop to improve readability and maintainability? Input: \n```URscript\nglobal position_1 = p[0.1, 0.2, 0.3, 0, 0, 0]\nglobal position_2 = p[0.4, 0.5, 0.6, 0, 0, 0]\nglobal position_3 = p[0.7, 0.8, 0.9, 0, 0, 0]\nmovel(position_1, a=0.2, v=0.5)\nmovel(position_2, a=0.2, v=0.5)\nmovel(position_3, a=0.2, v=0.5)\n```",
        "input": "<no_input>",
        "output": "```URscript\nglobal positions = [p[0.1, 0.2, 0.3, 0, 0, 0], p[0.4, 0.5, 0.6, 0, 0, 0], p[0.7, 0.8, 0.9, 0, 0, 0]]\nfor position in positions:\n  movel(position, a=0.2, v=0.5)\nend\n```"
    }
][
    {
        "instruction": "Could you refactor this URScript code to use a loop to improve readability and maintainability? Input: \n```URscript\nglobal position_1 = p[0.1, 0.2, 0.3, 0, 0, 0]\nglobal position_2 = p[0.4, 0.5, 0.6, 0, 0, 0]\nglobal position_3 = p[0.7, 0.8, 0.9, 0, 0, 0]\nmovel(position_1, a=0.2, v=0.5)\nmovel(position_2, a=0.2, v=0.5)\nmovel(position_3, a=0.2, v=0.5)\n```",
        "input": "<no_input>",
        "output": "```URscript\nglobal positions = [p[0.1, 0.2, 0.3, 0, 0, 0], p[0.4, 0.5, 0.6, 0, 0, 0], p[0.7, 0.8, 0.9, 0, 0, 0]]\nfor position in positions:\n  movel(position, a=0.2, v=0.5)\nend\n```"
    },
    {
        "instruction": "Generate a URScript function that activates a digital output based on an integer input. If the input is 1, activate digital output 0. If the input is 2, activate digital output 1. Otherwise, deactivate both.",
        "input": "<no_input>",
        "output": "```URscript\ndef activate_output(output_number):\n  if output_number == 1:\n    set_digital_out(0, True)\n    set_digital_out(1, False)\n  elif output_number == 2:\n    set_digital_out(0, False)\n    set_digital_out(1, True)\n  else:\n    set_digital_out(0, False)\n    set_digital_out(1, False)\n  end\nend\n```"
    }
][
    {
        "instruction": "Could you refactor this URScript code to use a loop to improve readability and maintainability? Input: \n```URscript\nglobal position_1 = p[0.1, 0.2, 0.3, 0, 0, 0]\nglobal position_2 = p[0.4, 0.5, 0.6, 0, 0, 0]\nglobal position_3 = p[0.7, 0.8, 0.9, 0, 0, 0]\nmovel(position_1, a=0.2, v=0.5)\nmovel(position_2, a=0.2, v=0.5)\nmovel(position_3, a=0.2, v=0.5)\n```",
        "input": "<no_input>",
        "output": "```URscript\nglobal positions = [p[0.1, 0.2, 0.3, 0, 0, 0], p[0.4, 0.5, 0.6, 0, 0, 0], p[0.7, 0.8, 0.9, 0, 0, 0]]\nfor position in positions:\n  movel(position, a=0.2, v=0.5)\nend\n```"
    },
    {
        "instruction": "Generate a URScript function that activates a digital output based on an integer input. If the input is 1, activate digital output 0. If the input is 2, activate digital output 1. Otherwise, deactivate both.",
        "input": "<no_input>",
        "output": "```URscript\ndef activate_output(output_number):\n  if output_number == 1:\n    set_digital_out(0, True)\n    set_digital_out(1, False)\n  elif output_number == 2:\n    set_digital_out(0, False)\n    set_digital_out(1, True)\n  else:\n    set_digital_out(0, False)\n    set_digital_out(1, False)\n  end\nend\n```"
    },
    {
        "instruction": "Construct a URScript function that moves the robot TCP to a new pose relative to the current TCP pose, then defines a new TCP offset, effectively transforming the new pose given relative to the base frame to be relative to the new tcp offset. Ensure no motion occurs in this definition and that the new definition is made according to the input variables.",
        "input": "```URscript\nrelative_position = p[0.1, 0.1, 0.1, 0, 0, 0]\nnew_tcp_offset_p = p[0.0, 0.0, 0.1, 0, 0, 0]\n```",
        "output": "```URscript\ndef define_new_tcp_offset(relative_position, new_tcp_offset_p):\n  current_tcp_pose = get_actual_tcp_pose()\n  new_tcp_pose = pose_add(current_tcp_pose, relative_position)\n  set_tcp(new_tcp_offset_p)\nend\n```"
    }
][
    {
        "instruction": "Could you refactor this URScript code to use a loop to improve readability and maintainability? Input: \n```URscript\nglobal position_1 = p[0.1, 0.2, 0.3, 0, 0, 0]\nglobal position_2 = p[0.4, 0.5, 0.6, 0, 0, 0]\nglobal position_3 = p[0.7, 0.8, 0.9, 0, 0, 0]\nmovel(position_1, a=0.2, v=0.5)\nmovel(position_2, a=0.2, v=0.5)\nmovel(position_3, a=0.2, v=0.5)\n```",
        "input": "<no_input>",
        "output": "```URscript\nglobal positions = [p[0.1, 0.2, 0.3, 0, 0, 0], p[0.4, 0.5, 0.6, 0, 0, 0], p[0.7, 0.8, 0.9, 0, 0, 0]]\nfor position in positions:\n  movel(position, a=0.2, v=0.5)\nend\n```"
    },
    {
        "instruction": "Generate a URScript function that activates a digital output based on an integer input. If the input is 1, activate digital output 0. If the input is 2, activate digital output 1. Otherwise, deactivate both.",
        "input": "<no_input>",
        "output": "```URscript\ndef activate_output(output_number):\n  if output_number == 1:\n    set_digital_out(0, True)\n    set_digital_out(1, False)\n  elif output_number == 2:\n    set_digital_out(0, False)\n    set_digital_out(1, True)\n  else:\n    set_digital_out(0, False)\n    set_digital_out(1, False)\n  end\nend\n```"
    },
    {
        "instruction": "Construct a URScript function that moves the robot TCP to a new pose relative to the current TCP pose, then defines a new TCP offset, effectively transforming the new pose given relative to the base frame to be relative to the new tcp offset. Ensure no motion occurs in this definition and that the new definition is made according to the input variables.",
        "input": "```URscript\nrelative_position = p[0.1, 0.1, 0.1, 0, 0, 0]\nnew_tcp_offset_p = p[0.0, 0.0, 0.1, 0, 0, 0]\n```",
        "output": "```URscript\ndef define_new_tcp_offset(relative_position, new_tcp_offset_p):\n  current_tcp_pose = get_actual_tcp_pose()\n  new_tcp_pose = pose_add(current_tcp_pose, relative_position)\n  set_tcp(new_tcp_offset_p)\nend\n```"
    },
    {
        "instruction": "Create a URScript function that reads an analog input on pin 0, scales it to a 0 to 100 percentage value based on the  minimum (0.0) and maximum (10.0) voltage values, and then returns this scaled percentage.",
        "input": "<no_input>",
        "output": "```URscript\ndef read_analog_percentage():\n  local min_voltage = 0.0\n  local max_voltage = 10.0\n  local analog_value = read_analog_in(0)\n  local percentage = (analog_value - min_voltage) / (max_voltage - min_voltage) * 100\n  return percentage\nend\n```"
    }
]