[
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], tool position and joint position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] and [-0.92, -1.26, -1.88, -1.73, 1.16, 0.88], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s with waypoint_1, 0.78 radian/s^2 and 0.87 radian/s with waypoint_2, we use active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given tool position and joint position, using active TCP:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n\tmovej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n\tmovej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n4. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n5. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n6. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool and joint position, and use active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given tool position and joint position, using active TCP:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n\tmovej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n\tmovej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n4. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n5. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n6. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], tool position and joint position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] and [-0.92, -1.26, -1.88, -1.73, 1.16, 0.88], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s with waypoint_1, 0.78 radian/s^2 and 0.87 radian/s with waypoint_2, we ignore active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given tool position and joint position, and ignore active TCP:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n    movej(get_inverse_kin(pose_trans(Waypoint_1_p, get_tcp_offset()), qnear=Waypoint_1_q), a=1.39, v=1.04)\n    movej(get_inverse_kin(pose_trans(Waypoint_2_p, get_tcp_offset()), qnear=Waypoint_2_q), a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n4. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n5. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n6. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space), qnear is list of joint positions (Optional)\n7. `pose_trans()`: pose transformation with 2 arguments are starting pose and pose change relative to starting pose \n8. `get_tcp_offset()`: get the active tcp offset\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool and joint position, and ignore active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given tool position and joint position, and ignore active TCP:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n    movej(get_inverse_kin(pose_trans(Waypoint_1_p, get_tcp_offset()), qnear=Waypoint_1_q), a=1.39, v=1.04)\n    movej(get_inverse_kin(pose_trans(Waypoint_2_p, get_tcp_offset()), qnear=Waypoint_2_q), a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n4. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n5. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n6. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space), qnear is list of joint positions (Optional)\n7. `pose_trans()`: pose transformation with 2 arguments are starting pose and pose change relative to starting pose \n8. `get_tcp_offset()`: get the active tcp offset\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given joint position of waypoint_1 is [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], joint position of waypoint_2 is [-0.92, -1.26, -1.88, -1.73, 1.16, 0.88], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s^2 with waypoint_1, 0.78 radian/s^2 and 0.87 radian/s with waypoint_2, use joint angles instead pose (tool position)",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given joint position, using joint angles:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n\tmovej(Waypoint_1_q, a=1.39, v=1.04)\n\tmovej(Waypoint_2_q, a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n2. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n3. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n\nNote that no joint position vector is provided so the current joint angles of the robot arm will be used. You can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool and joint position, use joint angles instead pose (tool positions)",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given joint position, using joint angles:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n\tmovej(Waypoint_1_q, a=1.39, v=1.04)\n\tmovej(Waypoint_2_q, a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n2. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n3. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n\nNote that no joint position vector is provided so the current joint angles of the robot arm will be used. You can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], tool position and joint position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] and [-0.92, -1.26, -1.88, -1.73, 1.16, 0.88], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s with waypoint_1, 0.78 radian/s^2 and 0.87 radian/s^2 with waypoint_2, we use active TCP, blend radius of waypoint_1 is 0.05m and waypoint_2 is 0.06m",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given tool position and joint position, using active TCP and blend radius:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n\tmovej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04, r=0.05)\n\tmovej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=0.78, v=0.87, r=0.06)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n4. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n5. `movej()`: command move robot to position in joint-space, given joint acceleration(a), joint speed(v) and blend radius (r)\n6. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool and joint position, and use active TCP and blend radius to smoothen the robot's movement",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given tool position and joint position, using active TCP and blend radius:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n\tmovej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04, r=0.05)\n\tmovej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=0.78, v=0.87, r=0.06)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n4. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n5. `movej()`: command move robot to position in joint-space, given joint acceleration(a), joint speed(v) and blend radius (r)\n6. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], tool position and joint position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] and [-0.92, -1.26, -1.88, -1.73, 1.16, 0.88], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s with waypoint_1, 0.78 radian/s^2 and 0.87 radian/s with waypoint_2, we use active TCP, time to make move of waypoint_1 is 2s and waypoint_2 is 3s",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given tool position and joint position, using active TCP and time to make move:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n    movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04, t=2.0)\n\tmovej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=0.78, v=0.87, t=3.0)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n4. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n5. `movej()`: command move robot to position in joint-space, given joint acceleration(a), joint speed(v) and time to make move (t)\n6. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints in joint-space given tool and joint position, and use active TCP and time to make move",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints in joint-space given tool position and joint position, using active TCP and time to make move:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03] # radian\n\n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n  local Waypoint_2_q=[-0.92, -1.26, -1.88, -1.73, 1.16, 0.88] # radian\n\n  while (True):\n    movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04, t=2.0)\n\tmovej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=0.78, v=0.87, t=3.0)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n4. `Waypoint_2_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_2\n5. `movej()`: command move robot to position in joint-space, given joint acceleration(a), joint speed(v) and time to make move (t)\n6. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot using relative point in joint-space, from position [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] to [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR using relative points in joint-space:\n\n```URscript\ndef move_joint_relative():\n  local Waypoint_1_from_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_to_p=p[-0.04, -0.2, 0.11, -0.004, 3.11, -0.18]\n  while (True):\n    movej(pose_add(get_target_tcp_pose(), pose_sub(Waypoint_1_to_p, Waypoint_1_from_p)), a=1.39, v=1.04)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_from_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_to_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movej()`: command move robot to position in joint-space, given tool acceleration(a) and tool speed(v)\n4. `pose_add()`: pose addition\n5. `get_target_tcp_pose()`: get the current target tool pose \n6. `pose_sub()`: pose subtraction\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot using relative points in joint-space",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR using relative points in joint-space:\n\n```URscript\ndef move_joint_relative():\n  local Waypoint_1_from_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_to_p=p[-0.04, -0.2, 0.11, -0.004, 3.11, -0.18]\n  while (True):\n    movej(pose_add(get_target_tcp_pose(), pose_sub(Waypoint_1_to_p, Waypoint_1_from_p)), a=1.39, v=1.04)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_from_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_to_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movej()`: command move robot to position in joint-space, given tool acceleration(a) and tool speed(v)\n4. `pose_add()`: pose addition\n5. `get_target_tcp_pose()`: get the current target tool pose \n6. `pose_sub()`: pose subtraction\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s^2 with waypoint_1, we use active TCP, until digial_in[0] = 1 then stop with joint acceleration is 1.39 radian/s^2",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until a expresion:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    local move_thread_flag=0\n    thread move_thread():\n      enter_critical\n      move_thread_flag = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag = 2\n      exit_critical\n    end\n\n    move_thread_flag = 0\n    move_thread_han = run move_thread()\n    while (True):\n      if (get_standard_digital_in(0) == 1):\n        kill move_thread_han\n        stopj(1.39)\n        break\n      end\n      sleep(1.0E-10)\n      if (move_thread_flag > 1):\n        join move_thread_han\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until digial_in[0] = 1",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until a expresion:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    local move_thread_flag=0\n    thread move_thread():\n      enter_critical\n      move_thread_flag = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag = 2\n      exit_critical\n    end\n\n    move_thread_flag = 0\n    move_thread_han = run move_thread()\n    while (True):\n      if (get_standard_digital_in(0) == 1):\n        kill move_thread_han\n        stopj(1.39)\n        break\n      end\n      sleep(1.0E-10)\n      if (move_thread_flag > 1):\n        join move_thread_han\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s^2 with waypoint_1, we use active TCP, until tool contact with distance is 0.001m then stop with joint acceleration is 34.9 radian/s^2",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until tool contact:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    global move_thread_flag_3=0\n    thread move_thread_3():\n      enter_critical\n      move_thread_flag_3 = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag_3 = 2\n      exit_critical\n    end\n\n    move_thread_flag_3 = 0\n    move_thread_han_3 = run move_thread_3()\n\n    while (True):\n      local targetTcpDirection=get_target_tcp_speed()\n      local stepsToRetract=tool_contact(direction=targetTcpDirection)\n      if (stepsToRetract > 0):\n        kill move_thread_han_3\n        stopj(34.9)\n        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)\n        local contactPose=get_forward_kin(backTrackMovement)\n        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]\n        local retractTo=contactPose\n        if (norm(posDir) > 1e-6):\n          local normalizedPosDir=normalize(posDir)\n\n          # distance is 0.001\n          local additionalRetraction=p[normalizedPosDir[0] * 0.001, normalizedPosDir[1] * 0.001, normalizedPosDir[2] * 0.001, 0, 0, 0] \n\n          retractTo = pose_sub(contactPose, additionalRetraction)\n        end\n        movej(retractTo, a=34.9, v=0.1)\n        break\n      end\n      sleep(1.0E-10)\n      if (move_thread_flag_3 > 1):\n        join move_thread_han_3\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until tool contact",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until tool contact:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    global move_thread_flag_3=0\n    thread move_thread_3():\n      enter_critical\n      move_thread_flag_3 = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag_3 = 2\n      exit_critical\n    end\n\n    move_thread_flag_3 = 0\n    move_thread_han_3 = run move_thread_3()\n\n    while (True):\n      local targetTcpDirection=get_target_tcp_speed()\n      local stepsToRetract=tool_contact(direction=targetTcpDirection)\n      if (stepsToRetract > 0):\n        kill move_thread_han_3\n        stopj(34.9)\n        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)\n        local contactPose=get_forward_kin(backTrackMovement)\n        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]\n        local retractTo=contactPose\n        if (norm(posDir) > 1e-6):\n          local normalizedPosDir=normalize(posDir)\n\n          # distance is 0.001\n          local additionalRetraction=p[normalizedPosDir[0] * 0.001, normalizedPosDir[1] * 0.001, normalizedPosDir[2] * 0.001, 0, 0, 0] \n\n          retractTo = pose_sub(contactPose, additionalRetraction)\n        end\n        movej(retractTo, a=34.9, v=0.1)\n        break\n      end\n      sleep(1.0E-10)\n      if (move_thread_flag_3 > 1):\n        join move_thread_han_3\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s^2 with waypoint_1, we use active TCP, until reached waypoint",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until reached waypoint:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    global move_thread_flag=0\n    thread move_thread():\n      enter_critical\n      move_thread_flag = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag = 2\n      exit_critical\n    end\n    move_thread_flag = 0\n    move_thread_han = run move_thread()\n    while (True):\n      sleep(1.0E-10)\n      if (move_thread_flag > 1):\n        join move_thread_han\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until reached waypoint",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until reached waypoint:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    global move_thread_flag=0\n    thread move_thread():\n      enter_critical\n      move_thread_flag = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag = 2\n      exit_critical\n    end\n    move_thread_flag = 0\n    move_thread_han = run move_thread()\n    while (True):\n      sleep(1.0E-10)\n      if (move_thread_flag > 1):\n        join move_thread_han\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s^2 with waypoint_1, we use active TCP, until digital_input[0] is low",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until change of I/O input:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    global move_thread_flag=0\n    thread move_thread():\n      enter_critical\n      move_thread_flag = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag = 2\n      exit_critical\n    end\n    move_thread_flag = 0\n    move_thread_han = run move_thread()\n    while (True):\n      if (get_standard_digital_in(0) == False):\n        kill move_thread_han\n        stopj(3.141592653589793)\n        break\n      end\n      sleep(1.0E-10)\n      if (move_thread_flag > 1):\n        join move_thread_han\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until change of I/O input",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until change of I/O input:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    global move_thread_flag=0\n    thread move_thread():\n      enter_critical\n      move_thread_flag = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag = 2\n      exit_critical\n    end\n    move_thread_flag = 0\n    move_thread_han = run move_thread()\n    while (True):\n      if (get_standard_digital_in(0) == False):\n        kill move_thread_han\n        stopj(3.141592653589793)\n        break\n      end\n      sleep(1.0E-10)\n      if (move_thread_flag > 1):\n        join move_thread_han\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool position and joint position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] and [-1.6, -1.72, -2.2, -0.8, 1.59, -0.03], joint acceleration and joint speed are 1.39 radian/s^2 and 1.04 radian/s^2 with waypoint_1, we use active TCP, until analog_input[0] larger than 4V",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until change of I/O input:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    global move_thread_flag=0\n    thread move_thread():\n      enter_critical\n      move_thread_flag = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag = 2\n      exit_critical\n    end\n    move_thread_flag = 0\n    move_thread_han = run move_thread()\n    while (True):\n      if (get_standard_analog_in(0) > 4.0):\n        kill move_thread_han\n        stopj(3.141592653589793)\n        break\n      end\n      sleep(1.0E-10)\n      if (move_thread_flag > 1):\n        join move_thread_han\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until change of I/O input",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints in joint-space given tool and joint position, and use active TCP, until change of I/O input:\n\n```URscript\ndef move_joint():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_q=[-1.6, -1.72, -2.2, -0.8, 1.59, -0.03]\n\n  while (True):\n    global move_thread_flag=0\n    thread move_thread():\n      enter_critical\n      move_thread_flag = 1\n      movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.39, v=1.04)\n      move_thread_flag = 2\n      exit_critical\n    end\n    move_thread_flag = 0\n    move_thread_han = run move_thread()\n    while (True):\n      if (get_standard_analog_in(0) > 4.0):\n        kill move_thread_han\n        stopj(3.141592653589793)\n        break\n      end\n      sleep(1.0E-10)\n      if (move_thread_flag > 1):\n        join move_thread_han\n        break\n      end\n      sync()\n    end\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_q`: joint position (Base, Shoulder, Elbow, Wrist 1, Wrist 2) of waypoint_1\n3. `thread`: using `run` keyword to run a thread, `join` to wait a running thread to finish and `kill` to kill a thread\n4. `movej()`: command move robot to position in joint-space, given joint acceleration(a) and joint speed(v)\n4. `stopj()`: command decelerate joint speeds to zero , given joint acceleration\n5. `get_inverse_kin()`: calculate the inverse kinematic transformation (tool space -> joint space) \n6. `sleep()`: sleep for an amount of time\n7. `sync()`: uses up the remaining \"physical\" time a thread has in the current frame \n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2 and 0.87 m/s with waypoint_2, we use active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, using active TCP:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movel(Waypoint_1_p, a=1.2, v=0.25)\n\tmovel(Waypoint_2_p, a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v)\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position, and use active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, using active TCP:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movel(Waypoint_1_p, a=1.2, v=0.25)\n\tmovel(Waypoint_2_p, a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v)\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2 and 0.87 m/s with waypoint_2, we ignore active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, using active TCP:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movel(pose_trans(Waypoint_1_p, get_tcp_offset()), a=1.2, v=0.25)\n    movel(pose_trans(Waypoint_2_p, get_tcp_offset()), a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v)\n4. `pose_trans()`: pose transformation with 2 arguments are starting pose and pose change relative to starting pose \n5. `get_tcp_offset()`: get the active tcp offset\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position, and ignore active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, using active TCP:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movel(pose_trans(Waypoint_1_p, get_tcp_offset()), a=1.2, v=0.25)\n    movel(pose_trans(Waypoint_2_p, get_tcp_offset()), a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v)\n4. `pose_trans()`: pose transformation with 2 arguments are starting pose and pose change relative to starting pose \n5. `get_tcp_offset()`: get the active tcp offset\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2 and 0.87 m/s with waypoint_2, we set manual TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, and set manual TCP:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n\t# set manual TCP\n    set_tcp(p[0.0,0.0,0.0,0.0,0.0,0.0])\n\n    movel(Waypoint_1_p, a=1.2, v=0.25)\n\tmovel(Waypoint_2_p, a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v)\n4. `set_tcp()`: set the active TCP offset\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position, and set manual TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, and set manual TCP:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n\t# set manual TCP\n    set_tcp(p[0.0,0.0,0.0,0.0,0.0,0.0])\n\n    movel(Waypoint_1_p, a=1.2, v=0.25)\n\tmovel(Waypoint_2_p, a=0.78, v=0.87)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v)\n4. `set_tcp()`: set the active TCP offset\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2 and 0.87 m/s with waypoint_2, we use active TCP and blend radius of waypoint_1 is 0.05m and waypoint_2 is 0.06m",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, using active TCP and blend radius to smoothen the robot's movement:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movel(Waypoint_1_p, a=1.2, v=0.25, r=0.05)\n\tmovel(Waypoint_2_p, a=0.78, v=0.87, r=0.06)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v), blend radius (r)\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position, and use active TCP and blend radius to smoothen the robot's movement",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, using active TCP and blend radius to smoothen the robot's movement:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movel(Waypoint_1_p, a=1.2, v=0.25, r=0.05)\n\tmovel(Waypoint_2_p, a=0.78, v=0.87, r=0.06)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v), blend radius (r)\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2 and 0.87 m/s with waypoint_2, we use active TCP and time to make move of waypoint_1 is 2s and waypoint_2 is 3s",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, using active TCP and time to make move:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movel(Waypoint_1_p, a=1.2, v=0.25, t=2.0)\n\tmovel(Waypoint_2_p, a=0.78, v=0.87, t=3.0)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v), time to make move (t)\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints linear in tool-space given tool position, and use active TCP and time to make move",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints linear in tool-space given tool position, using active TCP and time to make move:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movel(Waypoint_1_p, a=1.2, v=0.25, t=2.0)\n\tmovel(Waypoint_2_p, a=0.78, v=0.87, t=3.0)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given tool acceleration(a) and tool speed(v), time to make move (t)\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movel() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot using relative point linear in tool-space, from position [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] to [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR using relative points linear in tool-space:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_from_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_to_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217]\n\n  while (True):\n    movel(pose_add(get_target_tcp_pose(), pose_sub(Waypoint_1_to_p, Waypoint_1_from_p)), a=1.2, v=0.25)\n  end\nend\n```\n\n### Explaination:\n### Explaination:\n1. `Waypoint_1_from_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_to_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given joint acceleration(a) and joint speed(v)\n4. `pose_add()`: pose addition\n5. `get_target_tcp_pose()`: get the current target tool pose \n6. `pose_sub()`: pose subtraction\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot using relative points linear in tool-space",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR using relative points linear in tool-space:\n\n```URscript\ndef move_linear():\n  local Waypoint_1_from_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  local Waypoint_1_to_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217]\n\n  while (True):\n    movel(pose_add(get_target_tcp_pose(), pose_sub(Waypoint_1_to_p, Waypoint_1_from_p)), a=1.2, v=0.25)\n  end\nend\n```\n\n### Explaination:\n### Explaination:\n1. `Waypoint_1_from_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_1_to_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movel()`: command move robot to position linear in tool-space, given joint acceleration(a) and joint speed(v)\n4. `pose_add()`: pose addition\n5. `get_target_tcp_pose()`: get the current target tool pose \n6. `pose_sub()`: pose subtraction\n\nYou can modify the necessary parameters such as joint positions, or the velocity and acceleration of the movej() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints (move process) given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2 and 0.87 m/s with waypoint_2, we use active TCP and blend radius of waypoint 1 is 0.025m, and waypoint 2 is 0.02m",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints (move process) in joint-space given tool position, using active TCP:\n\n```URscript\ndef move_process():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movep(Waypoint_1_p, a=1.2, v=0.25, r=0.025)\n    movep(Waypoint_2_p, a=0.78, v=0.87, r=0.02)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movep()`: move process, blend circular (in tool-space) and move linear (in tool-space) to position, given tool acceleration(a), tool speed(v) and blend radius (r)\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movep() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints (move process) given tool position, and use active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints (move process) in joint-space given tool position, using active TCP:\n\n```URscript\ndef move_process():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movep(Waypoint_1_p, a=1.2, v=0.25, r=0.025)\n    movep(Waypoint_2_p, a=0.78, v=0.87, r=0.02)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movep()`: move process, blend circular (in tool-space) and move linear (in tool-space) to position, given tool acceleration(a), tool speed(v) and blend radius (r)\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movep() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints (move process) given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool position of waypoint_2 are [-0.008, -0.26, 0.28, -0.27, -2.71, 0.217], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2 and 0.87 m/s with waypoint_2, we ignore active TCP and blend radius of waypoint 1 is 0.025m, and waypoint 2 is 0.02m",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints (move process) in joint-space given tool position, ignore active TCP:\n\n```URscript\ndef move_process():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movep(pose_trans(Waypoint_1_p, get_tcp_offset()), a=1.2, v=0.25, r=0.025)\n    movep(pose_trans(Waypoint_2_p, get_tcp_offset()), a=0.78, v=0.87, r=0.02)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movep()`: move process, blend circular (in tool-space) and move linear (in tool-space) to position, given tool acceleration(a), tool speed(v) and blend radius (r)\n4. `pose_trans()`: pose transformation with 2 arguments are starting pose and pose change relative to starting pose \n5. `get_tcp_offset()`: get the active tcp offset\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movep() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot between 2 waypoints (move process) given tool position, and ignore active TCP",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot between 2 waypoints (move process) in joint-space given tool position, ignore active TCP:\n\n```URscript\ndef move_process():\n  local Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03] \n  local Waypoint_2_p=p[-0.008, -0.26, 0.28, -0.27, -2.71, 0.217] \n\n  while (True):\n    movep(pose_trans(Waypoint_1_p, get_tcp_offset()), a=1.2, v=0.25, r=0.025)\n    movep(pose_trans(Waypoint_2_p, get_tcp_offset()), a=0.78, v=0.87, r=0.02)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `Waypoint_2_p`: tool position (x, y, x, Rx, Ry, Rz) of waypoint_2\n3. `movep()`: move process, blend circular (in tool-space) and move linear (in tool-space) to position, given tool acceleration(a), tool speed(v) and blend radius (r)\n4. `pose_trans()`: pose transformation with 2 arguments are starting pose and pose change relative to starting pose \n5. `get_tcp_offset()`: get the active tcp offset\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movep() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints (move process) given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2n, we use active TCP and blend radius of waypoint 1 is 0.025m, and then add circle move with fixed mode between viapoint_1 and endpoint_1, with given tool position are [-0.08, -0.23, 0.14, -0.001, 3.11, 0.03] and [-0.03, -0.2, 0.17, 0.07, 3.11, 0.03], blend radius is 0.025m",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints (move process) given tool position, and use active TCP, and then add circle move in fixed mode: \n\n```URscript\ndef move_process():\n  global Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  global ViaPoint_1_p=p[-0.08, -0.23, 0.14, -0.001, 3.11, 0.03]\n  global EndPoint_1_p=p[-0.03, -0.2, 0.17, 0.07, 3.11, 0.03]\n\n  while (True):\n    movep(Waypoint_1_p, a=1.2, v=0.25, r=0.025)\n    movec(ViaPoint_1_p, EndPoint_1_p, a=1.2, v=0.25, r=0.025, mode=1)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `ViaPoint_1_p`: tool position (x, y, x, Rx, Ry, Rz) of viapoint_1\n3. `EndPoint_1_p`: tool position (x, y, x, Rx, Ry, Rz) of endpoint_1\n4. `movep()`: move process, blend circular (in tool-space) and move linear (in tool-space) to position, given tool acceleration(a), tool speed(v) and blend radius (r)\n5. `movec()`: move curcular in tool-space, given tool acceleration(a), tool speed(v), blend radius (r) and mode (fixed of unconstrained)\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movep() and movec() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints (move process) given tool position, and use active TCP, and then add circle move in fixed mode",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints (move process) given tool position, and use active TCP, and then add circle move in fixed mode: \n\n```URscript\ndef move_process():\n  global Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  global ViaPoint_1_p=p[-0.08, -0.23, 0.14, -0.001, 3.11, 0.03]\n  global EndPoint_1_p=p[-0.03, -0.2, 0.17, 0.07, 3.11, 0.03]\n\n  while (True):\n    movep(Waypoint_1_p, a=1.2, v=0.25, r=0.025)\n    movec(ViaPoint_1_p, EndPoint_1_p, a=1.2, v=0.25, r=0.025, mode=1)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `ViaPoint_1_p`: tool position (x, y, x, Rx, Ry, Rz) of viapoint_1\n3. `EndPoint_1_p`: tool position (x, y, x, Rx, Ry, Rz) of endpoint_1\n4. `movep()`: move process, blend circular (in tool-space) and move linear (in tool-space) to position, given tool acceleration(a), tool speed(v) and blend radius (r)\n5. `movec()`: move curcular in tool-space, given tool acceleration(a), tool speed(v), blend radius (r) and mode (fixed of unconstrained)\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movep() and movec() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints (move process) given tool position of waypoint_1 are [-0.13, -0.26, 0.14, -0.001, 3.11, 0.03], tool acceleration and tool speed are 1.2 m/s^2 and 0.78 m/s with waypoint_1, 0.78 m/s^2n, we use active TCP and blend radius of waypoint 1 is 0.025m, and then add circle move with unconstreained mode between viapoint_1 and endpoint_1, with given tool position are [-0.08, -0.23, 0.14, -0.001, 3.11, 0.03] and [-0.03, -0.2, 0.17, 0.07, 3.11, 0.03], blend radius is 0.025m",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints (move process) given tool position, and use active TCP, and then add circle move in unconstreained mode: \n\n```URscript\ndef move_process():\n  global Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  global ViaPoint_1_p=p[-0.08, -0.23, 0.14, -0.001, 3.11, 0.03]\n  global EndPoint_1_p=p[-0.03, -0.2, 0.17, 0.07, 3.11, 0.03]\n\n  while (True):\n    movep(Waypoint_1_p, a=1.2, v=0.25, r=0.025)\n    movec(ViaPoint_1_p, EndPoint_1_p, a=1.2, v=0.25, r=0.025)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `ViaPoint_1_p`: tool position (x, y, x, Rx, Ry, Rz) of viapoint_1\n3. `EndPoint_1_p`: tool position (x, y, x, Rx, Ry, Rz) of endpoint_1\n4. `movep()`: move process, blend circular (in tool-space) and move linear (in tool-space) to position, given tool acceleration(a), tool speed(v) and blend radius (r)\n5. `movec()`: move curcular in tool-space, given tool acceleration(a), tool speed(v), blend radius (r) and mode (fixed of unconstrained)\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movep() and movec() function."
    },
    {
        "instruction": "Define a URscript function can move UR robot to waypoints (move process) given tool position, and use active TCP, and then add circle move in unconstreained mode",
        "input": "",
        "output": "Here's a function in URscript that allow you to move UR robot to waypoints (move process) given tool position, and use active TCP, and then add circle move in unconstreained mode: \n\n```URscript\ndef move_process():\n  global Waypoint_1_p=p[-0.13, -0.26, 0.14, -0.001, 3.11, 0.03]\n  global ViaPoint_1_p=p[-0.08, -0.23, 0.14, -0.001, 3.11, 0.03]\n  global EndPoint_1_p=p[-0.03, -0.2, 0.17, 0.07, 3.11, 0.03]\n\n  while (True):\n    movep(Waypoint_1_p, a=1.2, v=0.25, r=0.025)\n    movec(ViaPoint_1_p, EndPoint_1_p, a=1.2, v=0.25, r=0.025)\n  end\nend\n```\n\n### Explaination:\n1. `Waypoint_1_p`: tool position or pose (x, y, x, Rx, Ry, Rz) of waypoint_1\n2. `ViaPoint_1_p`: tool position (x, y, x, Rx, Ry, Rz) of viapoint_1\n3. `EndPoint_1_p`: tool position (x, y, x, Rx, Ry, Rz) of endpoint_1\n4. `movep()`: move process, blend circular (in tool-space) and move linear (in tool-space) to position, given tool acceleration(a), tool speed(v) and blend radius (r)\n5. `movec()`: move curcular in tool-space, given tool acceleration(a), tool speed(v), blend radius (r) and mode (fixed of unconstrained)\n\nYou can modify the necessary parameters such as joint positions, tool positions, or the velocity and acceleration of the movep() and movec() function."
    }
]