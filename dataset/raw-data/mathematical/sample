def cross_product(u, v):
	
	u1 = u[0]
	u2 = u[1]
	u3 = u[2]
	v1 = v[0]
	v2 = v[1]
	v3 = v[2]
	
	s = [ (u2*v3-u3*v2), (u3*v1-u1*v3), (u1*v2-u2*v1) ]
	
	return s
end

def rotmat2rotvec(rotmat):

	# array to matrix
	r11 = rotmat[0]
	r21 = rotmat[1]
	r31 = rotmat[2]
	r12 = rotmat[3]
	r22 = rotmat[4]
	r32 = rotmat[5]
	r13 = rotmat[6]
	r23 = rotmat[7]
	r33 = rotmat[8]

	# rotation matrix to rotation vector
	theta = acos((r11+r22+r33-1)/2)
	sth = sin(theta)
	
	if ( (theta > d2r(179.99)) or (theta < d2r(-179.99)) ):
		theta = d2r(180)
		if (r21 < 0):
			if (r31 < 0):
				ux = sqrt((r11+1)/2)
				uy = -sqrt((r22+1)/2)
				uz = -sqrt((r33+1)/2)
			else:
				ux = sqrt((r11+1)/2)
				uy = -sqrt((r22+1)/2)
				uz = sqrt((r33+1)/2)
			end
		else:
			if (r31 < 0):
				ux = sqrt((r11+1)/2)
				uy = sqrt((r22+1)/2)
				uz = -sqrt((r33+1)/2)
			else:
				ux = sqrt((r11+1)/2)
				uy = sqrt((r22+1)/2)
				uz = sqrt((r33+1)/2)
			end
		end
	else:
		ux = (r32-r23)/(2*sth)
		uy = (r13-r31)/(2*sth)
		uz = (r21-r12)/(2*sth)
	end
	
	rotvec = [(theta*ux),(theta*uy),(theta*uz)]

	return rotvec
end

def get_feature_plane(p1, p2, p3):
	
	# Step 1. Get the direction vectors
	d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
	d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
	
	# Step 2. Get the direction vector of Z axis by cross product of d12 and d13
	dz = cross_product(d12, d13)
	
	# Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
	temp = norm(d12)
	ux = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
	temp = norm(dz)
	uz = [ dz[0]/temp, dz[1]/temp, dz[2]/temp ]
	
	# Step 4. Get Y unit direction vector by cross product of uz and ux
	uy = cross_product(uz, ux)
	
	# Step 5. Get the rotation matrix from the unit direction vectors
	rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
	
	# Step 6. Get the rotation vector from the rotation matrix
	rotvec = rotmat2rotvec(rotmat)
	
	# Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
	feature_plane = [ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
	
	return feature_plane
end

###############################################################
def frame_base2tool(rotvec, p_base):

	pose_rotvec = p[ 0, 0, 0, rotvec[0], rotvec[1], rotvec[2] ]
	pose_p_base = p[ p_base[0], p_base[1], p_base[2], 0, 0, 0 ]
		
	p_tool = pose_trans(pose_inv(pose_rotvec), pose_p_base)

	return p_tool
end

def get_tcp_force_tool():
	force_torque = get_tcp_force()
	force_B = [ force_torque[0], force_torque[1], force_torque[2] ]
	torque_B = [ force_torque[3], force_torque[4], force_torque[5] ]
	tcp = get_actual_tcp_pose()
	rotvec = [ tcp[3], tcp[4], tcp[5] ]	
	force_T = frame_base2tool( rotvec, force_B )
	torque_T = frame_base2tool( rotvec, torque_B )
	force_torque_T = p[ force_T[0], force_T[1], force_T[2], torque_T[0], torque_T[1], torque_T[2] ]
	return force_torque_T
end

###############################################################
def frame_base2tool(rotvec, p_base):

	pose_rotvec = p[ 0, 0, 0, rotvec[0], rotvec[1], rotvec[2] ]
	pose_p_base = p[ p_base[0], p_base[1], p_base[2], 0, 0, 0 ]
		
	p_tool = pose_trans(pose_inv(pose_rotvec), pose_p_base)

	return p_tool
end

def rotate_base(pose, angle, axis=3):

	rotvec = [ pose[3], pose[4], pose[5] ]
	if (axis == 1):
		axis_tool = frame_base2tool(rotvec, [1,0,0])
	elif (axis == 2): 
		axis_tool = frame_base2tool(rotvec, [0,1,0])
	else:
		axis_tool = frame_base2tool(rotvec, [0,0,1])
	end
		
	pose_rot = p[ 0, 0, 0, angle*axis_tool[0], angle*axis_tool[1], angle*axis_tool[2] ]
		
	target = pose_trans(pose, pose_rot)

	return target
end

###############################################################
def get_dh_parameter(gen,model):

	a_pose = p[ 0, 0, 0, 0, 0, 0 ]
	d_pose = p[ 0, 0, 0, 0, 0, 0 ]
	alpha_pose = p[ d2r(90), 0, 0, d2r(90), -d2r(90), 0 ]

	if (gen == 3):
		if (model == 3): 
			a_pose = p[ 0, -0.24365, -0.21325, 0, 0, 0 ]
			d_pose = p[ 0.1519, 0, 0, 0.11235, 0.08535, 0.0819 ]
		elif (model == 5):
			a_pose = p[ 0, -0.425, -0.39225, 0, 0, 0 ]
			d_pose = p[ 0.089159, 0, 0, 0.10915, 0.09465, 0.0823 ]
		elif (model == 10):
			a_pose = p[ 0, -0.612, -0.5723, 0, 0, 0 ]
			d_pose = p[ 0.1273, 0, 0, 0.163941, 0.1157, 0.0922 ]
		end
	elif (gen == 5 ):
		if (model == 3): 
			a_pose = p[ 0, -0.24355, -0.2132, 0, 0, 0 ]
			d_pose = p[ 0.15185, 0, 0, 0.13105, 0.08535, 0.0921 ]
		elif (model == 5):
			a_pose = p[ 0, -0.425, -0.3922, 0, 0, 0 ]
			d_pose = p[ 0.1625, 0, 0, 0.1333, 0.0997, 0.0996 ]
		elif (model == 10):
			a_pose = p[ 0, -0.6127, -0.57155, 0, 0, 0 ]
			d_pose = p[ 0.1807, 0, 0, 0.17415, 0.11985, 0.11655 ]
		end
	end
	
	dh_parameter = [ a_pose, d_pose, alpha_pose ]

	return dh_parameter
end

def get_transformation_pose_frame(gen, model, n, theta):

	# load the DH parameters
	dh_parameter = get_dh_parameter(gen, model)
	a_pose = dh_parameter[0]
	d_pose = dh_parameter[1]
	alpha_pose = dh_parameter[2]
	
	trans_z = p[0,0,d_pose[n-1],0,0,0]
	rot_z = p[0,0,0,0,0,theta[n-1]]
	trans_x = p[a_pose[n-1],0,0,0,0,0]
	rot_x = p[0,0,0,alpha_pose[n-1],0,0]
	
	pose = pose_trans(trans_z,pose_trans(rot_z,(pose_trans(trans_x,rot_x))))

	return pose
end

###############################################################
def get_wrist_origin(gen, model, theta, flange_pose):

	pose_4 = get_transformation_pose_frame(gen, model, 4, theta)
	pose_5 = get_transformation_pose_frame(gen, model, 5, theta)
	pose_6 = get_transformation_pose_frame(gen, model, 6, theta)
	pose_46 = pose_trans(pose_4, pose_trans(pose_5, pose_6))
	
	wrist_pose = pose_trans(flange_pose, pose_inv(pose_46))
	wrist_position = [ wrist_pose[0], wrist_pose[1], wrist_pose[2] ]
	
	return wrist_position
end
